"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[313],{520:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"chapters/gazebo-unity/ch4-introduction-to-gazebo","title":"Introduction to Gazebo Simulation","description":"Learning Objectives","source":"@site/docs/chapters/gazebo-unity/ch4-introduction-to-gazebo.mdx","sourceDirName":"chapters/gazebo-unity","slug":"/chapters/gazebo-unity/ch4-introduction-to-gazebo","permalink":"/docs/chapters/gazebo-unity/ch4-introduction-to-gazebo","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"ch4-introduction-to-gazebo","title":"Introduction to Gazebo Simulation","sidebar_label":"Introduction to Gazebo"},"sidebar":"textbookSidebar","previous":{"title":"Python Development","permalink":"/docs/chapters/ros2/ch3-python-development"},"next":{"title":"Robot Modeling and Control","permalink":"/docs/chapters/gazebo-unity/ch5-robot-modeling"}}');var r=i(4848),s=i(8453);const l={id:"ch4-introduction-to-gazebo",title:"Introduction to Gazebo Simulation",sidebar_label:"Introduction to Gazebo"},t=void 0,a={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Overview",id:"overview",level:2},{value:"What is Gazebo?",id:"what-is-gazebo",level:2},{value:"Key Features of Gazebo",id:"key-features-of-gazebo",level:3},{value:"Gazebo Components",id:"gazebo-components",level:3},{value:"Installing and Setting Up Gazebo",id:"installing-and-setting-up-gazebo",level:2},{value:"System Requirements",id:"system-requirements",level:3},{value:"Basic Installation",id:"basic-installation",level:3},{value:"Creating Simulation Worlds",id:"creating-simulation-worlds",level:2},{value:"World Format",id:"world-format",level:3},{value:"Basic World Structure",id:"basic-world-structure",level:3},{value:"Robot Modeling in Gazebo",id:"robot-modeling-in-gazebo",level:2},{value:"URDF vs SDF",id:"urdf-vs-sdf",level:3},{value:"Converting URDF to SDF",id:"converting-urdf-to-sdf",level:3},{value:"Basic Robot Model Example",id:"basic-robot-model-example",level:3},{value:"ROS 2 Integration",id:"ros-2-integration",level:2},{value:"Gazebo ROS Packages",id:"gazebo-ros-packages",level:3},{value:"Launching Gazebo with ROS 2",id:"launching-gazebo-with-ros-2",level:3},{value:"Basic Robot Control in Gazebo",id:"basic-robot-control-in-gazebo",level:2},{value:"Differential Drive Controller",id:"differential-drive-controller",level:3},{value:"Simple Controller Node",id:"simple-controller-node",level:3},{value:"Simulation Best Practices",id:"simulation-best-practices",level:2},{value:"Physics Tuning",id:"physics-tuning",level:3},{value:"Sensor Configuration",id:"sensor-configuration",level:3},{value:"Model Optimization",id:"model-optimization",level:3},{value:"Sim-to-Real Transfer Considerations",id:"sim-to-real-transfer-considerations",level:2},{value:"Domain Randomization",id:"domain-randomization",level:3},{value:"System Identification",id:"system-identification",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Performance Problems",id:"performance-problems",level:3},{value:"Stability Issues",id:"stability-issues",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Understand the core concepts of Gazebo simulation environment"}),"\n",(0,r.jsx)(n.li,{children:"Learn to create and configure simulation worlds"}),"\n",(0,r.jsx)(n.li,{children:"Master robot modeling and URDF creation for simulation"}),"\n",(0,r.jsx)(n.li,{children:"Implement basic robot control in simulated environments"}),"\n",(0,r.jsx)(n.li,{children:"Bridge the sim-to-real transfer gap"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"Gazebo is a powerful open-source 3D robot simulator that provides accurate physics simulation and realistic rendering capabilities. This chapter introduces Gazebo as a key tool for robotics development, covering its core features, world creation, robot modeling, and integration with ROS 2 for safe and cost-effective robot development."}),"\n",(0,r.jsx)(n.h2,{id:"what-is-gazebo",children:"What is Gazebo?"}),"\n",(0,r.jsx)(n.p,{children:"Gazebo is a 3D simulation environment that enables the development, testing, and validation of robot applications in a safe virtual environment. It provides:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Accurate physics simulation with multiple physics engines"}),"\n",(0,r.jsx)(n.li,{children:"High-quality rendering and visualization"}),"\n",(0,r.jsx)(n.li,{children:"Extensive sensor simulation capabilities"}),"\n",(0,r.jsx)(n.li,{children:"Plugin architecture for custom functionality"}),"\n",(0,r.jsx)(n.li,{children:"Seamless integration with ROS and ROS 2"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"key-features-of-gazebo",children:"Key Features of Gazebo"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Physics Engines"}),": Support for ODE, Bullet, DART, and Simbody"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sensor Simulation"}),": Cameras, LiDAR, IMU, GPS, force/torque sensors"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Realistic Rendering"}),": High-quality graphics with OGRE"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Plugin Architecture"}),": Extensible through custom plugins"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ROS Integration"}),": Native support for ROS/ROS 2 communication"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"gazebo-components",children:"Gazebo Components"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gazebo Server (gzserver)"}),": Runs the simulation engine"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gazebo Client (gzclient)"}),": Provides GUI interface"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gazebo Libraries"}),": APIs for programmatic control"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Model Database"}),": Repository of pre-built robot and environment models"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"installing-and-setting-up-gazebo",children:"Installing and Setting Up Gazebo"}),"\n",(0,r.jsx)(n.h3,{id:"system-requirements",children:"System Requirements"}),"\n",(0,r.jsx)(n.p,{children:"Gazebo requires:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Compatible operating system (Ubuntu, Windows, macOS)"}),"\n",(0,r.jsx)(n.li,{children:"OpenGL 2.0+ capable graphics card"}),"\n",(0,r.jsx)(n.li,{children:"Sufficient CPU and memory for physics simulation"}),"\n",(0,r.jsx)(n.li,{children:"ROS/ROS 2 installation (for ROS integration)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"basic-installation",children:"Basic Installation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Ubuntu installation\nsudo apt-get install gazebo libgazebo-dev\n\n# Or install with ROS 2\nsudo apt-get install ros-${ROS_DISTRO}-gazebo-ros-pkgs\n"})}),"\n",(0,r.jsx)(n.h2,{id:"creating-simulation-worlds",children:"Creating Simulation Worlds"}),"\n",(0,r.jsx)(n.h3,{id:"world-format",children:"World Format"}),"\n",(0,r.jsx)(n.p,{children:"Gazebo worlds are defined using SDF (Simulation Description Format), an XML-based format that describes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Physics properties (gravity, damping, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"Models (robots, obstacles, objects)"}),"\n",(0,r.jsx)(n.li,{children:"Environment properties (lighting, textures)"}),"\n",(0,r.jsx)(n.li,{children:"Plugins and extensions"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"basic-world-structure",children:"Basic World Structure"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.6">\n  <world name="my_world">\n    \x3c!-- Physics --\x3e\n    <physics type="ode">\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n\n    \x3c!-- Models --\x3e\n    <model name="ground_plane">\n      <pose>0 0 0 0 0 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n            </plane>\n          </geometry>\n        </collision>\n      </link>\n    </model>\n\n    \x3c!-- Lighting --\x3e\n    <light name="sun" type="directional">\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <attenuation>\n        <range>1000</range>\n        <constant>0.9</constant>\n        <linear>0.01</linear>\n        <quadratic>0.001</quadratic>\n      </attenuation>\n      <direction>-0.3 0.3 -1</direction>\n    </light>\n  </world>\n</sdf>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"robot-modeling-in-gazebo",children:"Robot Modeling in Gazebo"}),"\n",(0,r.jsx)(n.h3,{id:"urdf-vs-sdf",children:"URDF vs SDF"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"URDF (Unified Robot Description Format)"}),": Used primarily in ROS ecosystem"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SDF (Simulation Description Format)"}),": Used by Gazebo, more feature-rich"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"converting-urdf-to-sdf",children:"Converting URDF to SDF"}),"\n",(0,r.jsx)(n.p,{children:"Gazebo can directly load URDF files through the liburdf.so plugin, but for complex simulations, SDF is preferred."}),"\n",(0,r.jsx)(n.h3,{id:"basic-robot-model-example",children:"Basic Robot Model Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<robot name="simple_robot">\n  \x3c!-- Base link --\x3e\n  <link name="base_link">\n    <inertial>\n      <mass value="1.0" />\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01" />\n    </inertial>\n    <visual>\n      <geometry>\n        <box size="0.5 0.5 0.2" />\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 1 1" />\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.5 0.5 0.2" />\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Wheel links --\x3e\n  <link name="wheel_left">\n    <inertial>\n      <mass value="0.2" />\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.002" />\n    </inertial>\n    <visual>\n      <geometry>\n        <cylinder length="0.1" radius="0.15" />\n      </geometry>\n      <material name="black">\n        <color rgba="0 0 0 1" />\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="0.1" radius="0.15" />\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Joint between base and wheel --\x3e\n  <joint name="left_wheel_joint" type="continuous">\n    <parent link="base_link" />\n    <child link="wheel_left" />\n    <origin xyz="-0.2 0.2 -0.1" rpy="0 0 0" />\n    <axis xyz="0 1 0" />\n  </joint>\n</robot>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"ros-2-integration",children:"ROS 2 Integration"}),"\n",(0,r.jsx)(n.h3,{id:"gazebo-ros-packages",children:"Gazebo ROS Packages"}),"\n",(0,r.jsx)(n.p,{children:"The gazebo_ros_pkgs provide integration between Gazebo and ROS 2:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"gazebo_ros"}),": Core ROS 2 plugins for Gazebo"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"gazebo_plugins"}),": Specific plugins for sensors and actuators"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"gazebo_msgs"}),": Message and service definitions for Gazebo"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"launching-gazebo-with-ros-2",children:"Launching Gazebo with ROS 2"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    return LaunchDescription([\n        # Launch Gazebo with a world file\n        IncludeLaunchDescription(\n            PythonLaunchDescriptionSource([\n                PathJoinSubstitution([\n                    FindPackageShare('gazebo_ros'),\n                    'launch',\n                    'gazebo.launch.py'\n                ])\n            ]),\n            launch_arguments={'world': PathJoinSubstitution([\n                FindPackageShare('my_robot_pkg'),\n                'worlds',\n                'my_world.world'\n            ])}.items()\n        ),\n\n        # Spawn robot in Gazebo\n        Node(\n            package='gazebo_ros',\n            executable='spawn_entity.py',\n            arguments=[\n                '-entity', 'my_robot',\n                '-file', PathJoinSubstitution([\n                    FindPackageShare('my_robot_pkg'),\n                    'models',\n                    'my_robot.urdf'\n                ])\n            ],\n            output='screen'\n        )\n    ])\n"})}),"\n",(0,r.jsx)(n.h2,{id:"basic-robot-control-in-gazebo",children:"Basic Robot Control in Gazebo"}),"\n",(0,r.jsx)(n.h3,{id:"differential-drive-controller",children:"Differential Drive Controller"}),"\n",(0,r.jsx)(n.p,{children:"For wheeled robots, the differential drive controller is commonly used:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- In URDF/robot model --\x3e\n<gazebo>\n  <plugin name="diff_drive" filename="libgazebo_ros_diff_drive.so">\n    <left_joint>wheel_left_joint</left_joint>\n    <right_joint>wheel_right_joint</right_joint>\n    <wheel_separation>0.4</wheel_separation>\n    <wheel_diameter>0.3</wheel_diameter>\n    <command_topic>cmd_vel</command_topic>\n    <odometry_topic>odom</odometry_topic>\n    <odometry_frame>odom</odometry_frame>\n    <robot_base_frame>base_link</robot_base_frame>\n  </plugin>\n</gazebo>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"simple-controller-node",children:"Simple Controller Node"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom std_msgs.msg import Float64\n\nclass SimpleController(Node):\n    def __init__(self):\n        super().__init__('simple_controller')\n        self.cmd_vel_pub = self.create_publisher(Twist, 'cmd_vel', 10)\n\n        # Timer for control loop\n        self.timer = self.create_timer(0.1, self.control_loop)\n        self.i = 0\n\n    def control_loop(self):\n        msg = Twist()\n        # Simple oscillating motion\n        msg.linear.x = 0.5  # Move forward\n        msg.angular.z = 0.3 * (self.i % 10 > 5)  # Turn periodically\n        self.cmd_vel_pub.publish(msg)\n        self.i += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    controller = SimpleController()\n\n    try:\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"simulation-best-practices",children:"Simulation Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"physics-tuning",children:"Physics Tuning"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use appropriate solver parameters for your application"}),"\n",(0,r.jsx)(n.li,{children:"Tune damping coefficients for realistic movement"}),"\n",(0,r.jsx)(n.li,{children:"Adjust contact parameters for proper collision handling"}),"\n",(0,r.jsx)(n.li,{children:"Consider computational performance vs accuracy trade-offs"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"sensor-configuration",children:"Sensor Configuration"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Match sensor parameters to real hardware when possible"}),"\n",(0,r.jsx)(n.li,{children:"Add realistic noise models to sensor outputs"}),"\n",(0,r.jsx)(n.li,{children:"Configure appropriate update rates for your application"}),"\n",(0,r.jsx)(n.li,{children:"Validate sensor performance against real data"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"model-optimization",children:"Model Optimization"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use simplified collision geometries where possible"}),"\n",(0,r.jsx)(n.li,{children:"Optimize mesh complexity for performance"}),"\n",(0,r.jsx)(n.li,{children:"Implement Level of Detail (LOD) where appropriate"}),"\n",(0,r.jsx)(n.li,{children:"Consider using proxy models for distant objects"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"sim-to-real-transfer-considerations",children:"Sim-to-Real Transfer Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"domain-randomization",children:"Domain Randomization"}),"\n",(0,r.jsx)(n.p,{children:"To improve sim-to-real transfer, use domain randomization:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Randomize physics parameters (friction, mass, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"Vary lighting conditions and textures"}),"\n",(0,r.jsx)(n.li,{children:"Add sensor noise and bias"}),"\n",(0,r.jsx)(n.li,{children:"Change environmental conditions"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"system-identification",children:"System Identification"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Calibrate simulation parameters with real robot data"}),"\n",(0,r.jsx)(n.li,{children:"Identify discrepancies between simulation and reality"}),"\n",(0,r.jsx)(n.li,{children:"Adjust models to better match real-world behavior"}),"\n",(0,r.jsx)(n.li,{children:"Validate improvements with real-world experiments"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,r.jsx)(n.h3,{id:"performance-problems",children:"Performance Problems"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reduce model complexity for better performance"}),"\n",(0,r.jsx)(n.li,{children:"Use appropriate update rates for physics and sensors"}),"\n",(0,r.jsx)(n.li,{children:"Consider using simpler physics engines for initial testing"}),"\n",(0,r.jsx)(n.li,{children:"Limit the number of active sensors in simulation"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"stability-issues",children:"Stability Issues"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Check inertial parameters in robot models"}),"\n",(0,r.jsx)(n.li,{children:"Verify joint limits and effort/torque constraints"}),"\n",(0,r.jsx)(n.li,{children:"Adjust physics solver parameters if needed"}),"\n",(0,r.jsx)(n.li,{children:"Use appropriate PID gains for controllers"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"This chapter introduced Gazebo as a powerful simulation environment for robotics development. We covered world creation, robot modeling, ROS 2 integration, and basic control techniques. Gazebo is essential for safe, cost-effective robot development and enables rapid prototyping and testing of complex robotic systems before deployment on real hardware."}),"\n",(0,r.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"World Creation"}),": Create a custom Gazebo world with obstacles and test your robot's navigation capabilities."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Robot Modeling"}),": Design a URDF model of a simple robot with multiple sensors and import it into Gazebo."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Controller Implementation"}),": Implement a controller that makes your robot navigate to a specific goal in Gazebo while avoiding obstacles."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>t});var o=i(6540);const r={},s=o.createContext(r);function l(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);