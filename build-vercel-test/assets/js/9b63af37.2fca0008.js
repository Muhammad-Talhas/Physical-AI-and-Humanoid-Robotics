"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[560],{8453:(i,n,e)=>{e.d(n,{R:()=>a,x:()=>t});var s=e(6540);const r={},l=s.createContext(r);function a(i){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof i?i(n):{...n,...i}},[n,i])}function t(i){let n;return n=i.disableParentContext?"function"==typeof i.components?i.components(r):i.components||r:a(i.components),s.createElement(l.Provider,{value:n},i.children)}},8572:(i,n,e)=>{e.r(n),e.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"chapters/digital-twin-simulation/01-digital-twin-simulation","title":"Digital Twin Simulation (Gazebo + Isaac)","description":"Learning Objectives","source":"@site/docs/chapters/digital-twin-simulation/01-digital-twin-simulation.mdx","sourceDirName":"chapters/digital-twin-simulation","slug":"/chapters/digital-twin-simulation/01-digital-twin-simulation","permalink":"/docs/chapters/digital-twin-simulation/01-digital-twin-simulation","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"01-digital-twin-simulation","title":"Digital Twin Simulation (Gazebo + Isaac)","sidebar_label":"4. Digital Twin Simulation (Gazebo + Isaac)"}}');var r=e(4848),l=e(8453);const a={id:"01-digital-twin-simulation",title:"Digital Twin Simulation (Gazebo + Isaac)",sidebar_label:"4. Digital Twin Simulation (Gazebo + Isaac)"},t=void 0,o={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Overview",id:"overview",level:2},{value:"4.1 Introduction to Digital Twin Simulation",id:"41-introduction-to-digital-twin-simulation",level:2},{value:"Key Components of a Digital Twin",id:"key-components-of-a-digital-twin",level:3},{value:"4.2 Gazebo Simulation Environment",id:"42-gazebo-simulation-environment",level:2},{value:"Key Features of Gazebo",id:"key-features-of-gazebo",level:3},{value:"Gazebo Components",id:"gazebo-components",level:3},{value:"4.3 NVIDIA Isaac Sim",id:"43-nvidia-isaac-sim",level:2},{value:"Key Features of Isaac Sim",id:"key-features-of-isaac-sim",level:3},{value:"4.4 Simulation vs Reality Gap",id:"44-simulation-vs-reality-gap",level:2},{value:"Common Simulation Challenges",id:"common-simulation-challenges",level:3},{value:"Bridging the Gap",id:"bridging-the-gap",level:3},{value:"Simulation Concepts",id:"simulation-concepts",level:2},{value:"Simulation Pipeline",id:"simulation-pipeline",level:3},{value:"Sensor Modeling",id:"sensor-modeling",level:3},{value:"Physics Parameters",id:"physics-parameters",level:3},{value:"4.5 Gazebo Setup and Usage",id:"45-gazebo-setup-and-usage",level:2},{value:"Launching Gazebo",id:"launching-gazebo",level:3},{value:"Creating Robot Models",id:"creating-robot-models",level:3},{value:"Plugin Integration",id:"plugin-integration",level:3},{value:"4.6 Isaac Sim Integration",id:"46-isaac-sim-integration",level:2},{value:"Key Features for Robotics",id:"key-features-for-robotics",level:3},{value:"Isaac Sim Workflows",id:"isaac-sim-workflows",level:3},{value:"4.7 Best Practices for Simulation",id:"47-best-practices-for-simulation",level:2},{value:"Model Accuracy",id:"model-accuracy",level:3},{value:"Scenario Design",id:"scenario-design",level:3},{value:"Validation Strategies",id:"validation-strategies",level:3},{value:"4.8 Simulation in the Development Cycle",id:"48-simulation-in-the-development-cycle",level:2},{value:"Development Phases",id:"development-phases",level:3},{value:"Integration with CI/CD",id:"integration-with-cicd",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2}];function c(i){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...i.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Understand the concept of digital twins in robotics"}),"\n",(0,r.jsx)(n.li,{children:"Learn about Gazebo and NVIDIA Isaac Sim simulation environments"}),"\n",(0,r.jsx)(n.li,{children:"Master simulation tools for robotics development"}),"\n",(0,r.jsx)(n.li,{children:"Explore the integration of simulation with real-world systems"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"Digital twin simulation represents a virtual replica of a physical robot system that mirrors its real-world counterpart in real-time. This chapter explores simulation environments like Gazebo and NVIDIA Isaac Sim, focusing on how to create accurate digital twins that bridge the gap between simulation and reality for robotics development."}),"\n",(0,r.jsx)(n.h2,{id:"41-introduction-to-digital-twin-simulation",children:"4.1 Introduction to Digital Twin Simulation"}),"\n",(0,r.jsx)(n.p,{children:"A digital twin in robotics is a virtual representation of a physical robot that simulates its behavior, characteristics, and interactions with the environment. This approach allows for:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Safe Testing"}),": Experiment with algorithms without physical risk"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cost Reduction"}),": Reduce hardware costs and maintenance"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Accelerated Development"}),": Rapid iteration and testing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Predictive Analysis"}),": Forecast robot behavior in various scenarios"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"key-components-of-a-digital-twin",children:"Key Components of a Digital Twin"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Geometric Model"}),": Accurate 3D representation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Physical Properties"}),": Mass, friction, material properties"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sensor Models"}),": Camera, LiDAR, IMU, etc."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Actuator Models"}),": Motor dynamics and limitations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Environment"}),": Physics and interaction models"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"42-gazebo-simulation-environment",children:"4.2 Gazebo Simulation Environment"}),"\n",(0,r.jsx)(n.p,{children:"Gazebo is an open-source 3D robotics simulator that provides accurate physics simulation and rendering capabilities."}),"\n",(0,r.jsx)(n.h3,{id:"key-features-of-gazebo",children:"Key Features of Gazebo"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Physics Engines"}),": Supports ODE, Bullet, DART, Simbody"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sensor Simulation"}),": Cameras, LiDAR, IMU, GPS, etc."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Plugin Architecture"}),": Extensible through plugins"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ROS Integration"}),": Seamless integration with ROS/ROS 2"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Realistic Rendering"}),": High-quality graphics with OGRE"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"gazebo-components",children:"Gazebo Components"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gazebo Server"}),": Runs the simulation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gazebo Client"}),": Provides GUI interface"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Libraries"}),": APIs for programmatic control"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"43-nvidia-isaac-sim",children:"4.3 NVIDIA Isaac Sim"}),"\n",(0,r.jsx)(n.p,{children:"NVIDIA Isaac Sim is a high-fidelity simulation environment built on NVIDIA Omniverse, designed for robotics development with advanced graphics and physics."}),"\n",(0,r.jsx)(n.h3,{id:"key-features-of-isaac-sim",children:"Key Features of Isaac Sim"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Photo-realistic Graphics"}),": Physically-based rendering"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"AI Training Environment"}),": Optimized for reinforcement learning"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Modular Framework"}),": Flexible and extensible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Synthetic Data Generation"}),": High-quality training data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Realistic Physics"}),": Advanced physics simulation"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"44-simulation-vs-reality-gap",children:"4.4 Simulation vs Reality Gap"}),"\n",(0,r.jsx)(n.p,{children:'The "reality gap" refers to the differences between simulation and the real world that can affect performance when transferring learned behaviors or controllers from simulation to reality.'}),"\n",(0,r.jsx)(n.h3,{id:"common-simulation-challenges",children:"Common Simulation Challenges"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Physics Approximation"}),": Simplified physics models"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sensor Noise"}),": Imperfect sensor modeling"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Actuator Dynamics"}),": Inaccurate motor modeling"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Environmental Factors"}),": Lighting, texture, friction variations"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"bridging-the-gap",children:"Bridging the Gap"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Domain Randomization"}),": Randomize simulation parameters"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"System Identification"}),": Calibrate models with real data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sim-to-Real Transfer"}),": Progressive adaptation techniques"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mixed Reality"}),": Combine simulation with real-world data"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"simulation-concepts",children:"Simulation Concepts"}),"\n",(0,r.jsx)(n.h3,{id:"simulation-pipeline",children:"Simulation Pipeline"}),"\n",(0,r.jsx)(n.p,{children:"The flow from simulation to real robot involves:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Virtual Robot \u2192 Algorithm \u2192 Real Robot"}),"\n",(0,r.jsx)(n.li,{children:"Sim-to-Real Transfer Pipeline"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Domain Randomization Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import random\r\n\r\nclass DomainRandomizer:\r\n    def __init__(self):\r\n        self.params = {\r\n            'friction': (0.1, 1.0),\r\n            'mass': (0.5, 2.0),\r\n            'gravity': (9.0, 10.0),\r\n            'lighting': (0.5, 1.5)\r\n        }\r\n\r\n    def randomize_environment(self):\r\n        randomized_params = {}\r\n        for param, (min_val, max_val) in self.params.items():\r\n            randomized_params[param] = random.uniform(min_val, max_val)\r\n        return randomized_params\n"})}),"\n",(0,r.jsx)(n.h3,{id:"sensor-modeling",children:"Sensor Modeling"}),"\n",(0,r.jsx)(n.p,{children:"Simulating different sensor types: Camera, LiDAR, IMU, and GPS for multi-sensor simulation in digital twins."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Sensor Noise Model Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import random\r\nimport numpy as np\r\n\r\nclass SensorModel:\r\n    def __init__(self, noise_std=0.01):\r\n        self.noise_std = noise_std\r\n\r\n    def add_noise(self, sensor_data):\r\n        noisy_data = []\r\n        for value in sensor_data:\r\n            noise = random.gauss(0, self.noise_std)\r\n            noisy_value = value + noise\r\n            noisy_data.append(noisy_value)\r\n        return noisy_data\r\n\r\n    def camera_noise(self, image):\r\n        # Add realistic camera noise\r\n        noise = np.random.normal(0, self.noise_std, image.shape)\r\n        noisy_image = np.clip(image + noise, 0, 255)\r\n        return noisy_image\n"})}),"\n",(0,r.jsx)(n.h3,{id:"physics-parameters",children:"Physics Parameters"}),"\n",(0,r.jsx)(n.p,{children:"Adjustable simulation parameters include:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Friction: 0.5"}),"\n",(0,r.jsx)(n.li,{children:"Mass: 1.2kg"}),"\n",(0,r.jsx)(n.li,{children:"Gravity: 9.8"}),"\n",(0,r.jsx)(n.li,{children:"Damping: 0.1"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Physics Configuration Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class PhysicsConfig:\r\n    def __init__(self):\r\n        self.gravity = [0.0, 0.0, -9.81]\r\n        self.friction = 0.5\r\n        self.linear_damping = 0.01\r\n        self.angular_damping = 0.01\r\n        self.contact_surface_layer = 0.001\r\n\r\n    def update_config(self, **kwargs):\r\n        for key, value in kwargs.items():\r\n            if hasattr(self, key):\r\n                setattr(self, key, value)\r\n\r\n    def to_gazebo_format(self):\r\n        return {\r\n            'gravity': self.gravity,\r\n            'ode_config': {\r\n                'friction': self.friction,\r\n                'linear_damping': self.linear_damping,\r\n                'angular_damping': self.angular_damping\r\n            }\r\n        }\n"})}),"\n",(0,r.jsx)(n.h2,{id:"45-gazebo-setup-and-usage",children:"4.5 Gazebo Setup and Usage"}),"\n",(0,r.jsx)(n.h3,{id:"launching-gazebo",children:"Launching Gazebo"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Launch Gazebo with empty world\r\nros2 launch gazebo_ros gazebo.launch.py\r\n\r\n# Launch with specific world\r\nros2 launch gazebo_ros gzserver.launch.py world:=my_world.sdf\n"})}),"\n",(0,r.jsx)(n.h3,{id:"creating-robot-models",children:"Creating Robot Models"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"URDF"}),": Unified Robot Description Format"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SDF"}),": Simulation Description Format"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Meshes"}),": 3D geometry files"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Materials"}),": Visual appearance definitions"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"plugin-integration",children:"Plugin Integration"}),"\n",(0,r.jsx)(n.p,{children:"Gazebo plugins extend functionality:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Controller Plugins"}),": Motor and actuator control"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sensor Plugins"}),": Custom sensor simulation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"World Plugins"}),": Environmental effects"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"GUI Plugins"}),": Custom interfaces"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"46-isaac-sim-integration",children:"4.6 Isaac Sim Integration"}),"\n",(0,r.jsx)(n.h3,{id:"key-features-for-robotics",children:"Key Features for Robotics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Omniverse Platform"}),": Collaborative simulation environment"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"USD Format"}),": Universal Scene Description"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Real-time Physics"}),": NVIDIA PhysX engine"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"AI Training"}),": Built-in reinforcement learning tools"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"isaac-sim-workflows",children:"Isaac Sim Workflows"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Asset Creation"}),": Building robot and environment models"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simulation Scenarios"}),": Creating test environments"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Data Generation"}),": Synthetic training data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Algorithm Testing"}),": RL and planning algorithms"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"47-best-practices-for-simulation",children:"4.7 Best Practices for Simulation"}),"\n",(0,r.jsx)(n.h3,{id:"model-accuracy",children:"Model Accuracy"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use high-fidelity geometric models"}),"\n",(0,r.jsx)(n.li,{children:"Calibrate physical properties with real measurements"}),"\n",(0,r.jsx)(n.li,{children:"Validate sensor models against real hardware"}),"\n",(0,r.jsx)(n.li,{children:"Account for computational delays"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"scenario-design",children:"Scenario Design"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Create diverse testing environments"}),"\n",(0,r.jsx)(n.li,{children:"Include edge cases and failure modes"}),"\n",(0,r.jsx)(n.li,{children:"Gradually increase difficulty"}),"\n",(0,r.jsx)(n.li,{children:"Document simulation parameters"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"validation-strategies",children:"Validation Strategies"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Cross-validate with real-world data"}),"\n",(0,r.jsx)(n.li,{children:"Use multiple simulation environments"}),"\n",(0,r.jsx)(n.li,{children:"Test boundary conditions"}),"\n",(0,r.jsx)(n.li,{children:"Monitor simulation stability"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"48-simulation-in-the-development-cycle",children:"4.8 Simulation in the Development Cycle"}),"\n",(0,r.jsx)(n.h3,{id:"development-phases",children:"Development Phases"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Concept Testing"}),": Algorithm feasibility in simple environments"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance Tuning"}),": Optimization in complex scenarios"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Robustness Testing"}),": Edge cases and failure recovery"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transfer Validation"}),": Real-world deployment verification"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"integration-with-cicd",children:"Integration with CI/CD"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Automated simulation testing"}),"\n",(0,r.jsx)(n.li,{children:"Regression testing for algorithms"}),"\n",(0,r.jsx)(n.li,{children:"Performance benchmarking"}),"\n",(0,r.jsx)(n.li,{children:"Documentation generation"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"This chapter covered digital twin simulation concepts, focusing on Gazebo and NVIDIA Isaac Sim environments. We explored the challenges of bridging the sim-to-real gap and best practices for creating accurate digital twins. Simulation is crucial for safe, cost-effective robotics development and enables rapid prototyping and testing of complex robotic systems."}),"\n",(0,r.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Model Creation"}),": Create a URDF model of a simple robot and import it into Gazebo with basic sensors."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simulation Comparison"}),": Compare the behavior of a simple controller in Gazebo and Isaac Sim for the same robot model."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Domain Randomization"}),": Implement a domain randomization technique for a simple simulation environment to improve sim-to-real transfer."]}),"\n"]}),"\n"]})]})}function h(i={}){const{wrapper:n}={...(0,l.R)(),...i.components};return n?(0,r.jsx)(n,{...i,children:(0,r.jsx)(c,{...i})}):c(i)}}}]);