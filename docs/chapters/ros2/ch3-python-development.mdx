---
id: ch3-python-development
title: ROS 2 Development in Python
sidebar_label: Python Development
---

## Learning Objectives

- Write ROS 2 nodes in Python using `rclpy`.
- Implement publishers and subscribers for asynchronous communication.
- Create service clients and servers for synchronous interactions.
- Develop action clients and servers for complex, long-running tasks.

## Overview

Python is a popular language for robotics due to its readability, extensive libraries, and rapid development capabilities. This chapter provides a hands-on guide to developing ROS 2 applications using `rclpy`, the Python client library for ROS 2. We will cover the implementation of nodes, topics, services, and actions with practical code examples.

## Setting up a ROS 2 Python Workspace

Before writing our first ROS 2 Python code, ensure you have a ROS 2 workspace set up. For Python packages, we typically use `colcon` with `ament_python`.

### Creating a new ROS 2 Python package

```bash
# Navigate to your ROS 2 workspace src directory
cd ~/ros2_ws/src

# Create a new Python package
ros2 pkg create --build-type ament_python my_python_pkg --dependencies rclpy std_msgs

# Go back to the workspace root and build
cd ~/ros2_ws
colcon build

# Source the workspace
. install/setup.bash
```

This creates a directory `my_python_pkg` with a basic structure, including `setup.py` and `package.xml`.

## Writing a ROS 2 Python Node

A basic ROS 2 node in Python involves importing `rclpy` and creating a node instance.

```python
# my_python_pkg/my_python_pkg/my_node.py

import rclpy
from rclpy.node import Node

class MyNode(Node):

    def __init__(self):
        super().__init__('my_node')
        self.get_logger().info('MyNode has been started!')

def main(args=None):
    rclpy.init(args=args)
    my_node = MyNode()
    rclpy.spin(my_node)
    my_node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

To make this executable, add an entry point in `setup.py`:

```python
# setup.py (excerpt)
# ...
entry_points={
    'console_scripts': [
        'my_node = my_python_pkg.my_node:main',
    ],
},
# ...
```

Build and run:

```bash
cd ~/ros2_ws
colcon build
. install/setup.bash
ros2 run my_python_pkg my_node
```

## Implementing Publishers and Subscribers

### Publisher Example

```python
# my_python_pkg/my_python_pkg/simple_publisher.py

import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SimplePublisher(Node):

    def __init__(self):
        super().__init__('simple_publisher')
        self.publisher_ = self.create_publisher(String, 'chatter', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello ROS 2: {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    simple_publisher = SimplePublisher()
    rclpy.spin(simple_publisher)
    simple_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

Add to `setup.py` entry points and rebuild.

### Subscriber Example

```python
# my_python_pkg/my_python_pkg/simple_subscriber.py

import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SimpleSubscriber(Node):

    def __init__(self):
        super().__init__('simple_subscriber')
        self.subscription = self.create_subscription(
            String,
            'chatter',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    simple_subscriber = SimpleSubscriber()
    rclpy.spin(simple_subscriber)
    simple_subscriber.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

Add to `setup.py` entry points and rebuild.

## Implementing Services

### Service Definition (example_interfaces/srv/AddTwoInts.srv)

ROS 2 services require a `.srv` file. Let's use `example_interfaces/srv/AddTwoInts.srv` (which defines `int64 a`, `int64 b` as request and `int64 sum` as response).

### Service Server Example

```python
# my_python_pkg/my_python_pkg/simple_service_server.py

import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts

class SimpleServiceServer(Node):

    def __init__(self):
        super().__init__('simple_service_server')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)
        self.get_logger().info('Service server ready.')

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'Incoming request: a={request.a}, b={request.b}')
        self.get_logger().info(f'Sending back response: {response.sum}')
        return response

def main(args=None):
    rclpy.init(args=args)
    simple_service_server = SimpleServiceServer()
    rclpy.spin(simple_service_server)
    simple_service_server.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Service Client Example

```python
# my_python_pkg/my_python_pkg/simple_service_client.py

import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts
import sys

class SimpleServiceClient(Node):

    def __init__(self):
        super().__init__('simple_service_client')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('service not available, waiting again...')
        self.req = AddTwoInts.Request()

    def send_request(self, a, b):
        self.req.a = a
        self.req.b = b
        self.future = self.cli.call_async(self.req)
        rclpy.spin_until_future_complete(self, self.future)
        return self.future.result()

def main(args=None):
    rclpy.init(args=args)

    if len(sys.argv) != 3:
        print('Usage: ros2 run my_python_pkg simple_service_client <arg1> <arg2>')
        return

    simple_service_client = SimpleServiceClient()
    response = simple_service_client.send_request(int(sys.argv[1]), int(sys.argv[2]))
    simple_service_client.get_logger().info(
        f'Result of add_two_ints: for {int(sys.argv[1])} + {int(sys.argv[2])} = {response.sum}')

    simple_service_client.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

Add entry points in `setup.py` and rebuild.

## Implementing Actions

### Action Definition (example_interfaces/action/Fibonacci.action)

Actions require a `.action` file. Let's use `example_interfaces/action/Fibonacci.action` (which defines `int32 order` as goal, `int32[] sequence` as result, and `int32[] sequence` as feedback).

### Action Server Example

```python
# my_python_pkg/my_python_pkg/simple_action_server.py

import rclpy
from rclpy.action import ActionServer
from rclpy.node import Node

from example_interfaces.action import Fibonacci

class SimpleActionServer(Node):

    def __init__(self):
        super().__init__('simple_action_server')
        self._action_server = ActionServer(
            self,
            Fibonacci,
            'fibonacci',
            self.execute_callback)

    def execute_callback(self, goal_handle):
        self.get_logger().info('Executing goal...')

        feedback_msg = Fibonacci.Feedback()
        feedback_msg.sequence = [0, 1]

        for i in range(1, goal_handle.request.order):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.get_logger().info('Goal canceled')
                return Fibonacci.Result()

            feedback_msg.sequence.append(
                feedback_msg.sequence[i] + feedback_msg.sequence[i-1])
            self.get_logger().info('Feedback: {0}'.format(feedback_msg.sequence))
            goal_handle.publish_feedback(feedback_msg)
            # Simulate long-running task
            # time.sleep(1)

        goal_handle.succeed()

        result = Fibonacci.Result()
        result.sequence = feedback_msg.sequence
        self.get_logger().info('Result: {0}'.format(result.sequence))
        return result

def main(args=None):
    rclpy.init(args=args)
    simple_action_server = SimpleActionServer()
    rclpy.spin(simple_action_server)

if __name__ == '__main__':
    main()
```

### Action Client Example

```python
# my_python_pkg/my_python_pkg/simple_action_client.py

import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node

from example_interfaces.action import Fibonacci

class SimpleActionClient(Node):

    def __init__(self):
        super().__init__('simple_action_client')
        self._action_client = ActionClient(self, Fibonacci, 'fibonacci')

    def send_goal(self, order):
        goal_msg = Fibonacci.Goal()
        goal_msg.order = order

        self.get_logger().info('Waiting for action server...')
        self._action_client.wait_for_server()

        self.get_logger().info('Sending goal request...')
        self._send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback)

        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected :(')
            return

        self.get_logger().info('Goal accepted :)')

        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def get_result_callback(self, future):
        result = future.result().result
        self.get_logger().info('Result: {0}'.format(result.sequence))
        rclpy.shutdown()

    def feedback_callback(self, feedback_msg):
        self.get_logger().info('Received feedback: {0}'.format(feedback_msg.feedback.sequence))

def main(args=None):
    rclpy.init(args=args)
    action_client = SimpleActionClient()
    action_client.send_goal(10)
    rclpy.spin(action_client)

if __name__ == '__main__':
    main()
```

Add entry points in `setup.py` and rebuild.

## Summary

This chapter provided a comprehensive guide to ROS 2 development in Python using `rclpy`. We covered the creation of nodes and implemented all three core communication patterns: topics for asynchronous data, services for synchronous request-response, and actions for long-running tasks with feedback. These examples form the foundation for building sophisticated robotic applications.

## Exercises

1.  **Modify Publisher**: Extend the `SimplePublisher` node to publish custom messages (e.g., `geometry_msgs/msg/Point`). You will need to define a custom message in a `.msg` file first.
2.  **Combine Communication**: Create a single Python node that acts as both a publisher and a subscriber, e.g., publishing `cmd_vel` commands and subscribing to `odom` data.
3.  **Error Handling**: Enhance the service client to include error handling for cases where the service server is not available or returns an error.
